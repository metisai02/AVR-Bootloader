
BootloaderAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  0000720c  000002a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000020c  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800112  00800112  000002b2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000002b2  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000c0  00000000  00000000  000002e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000931  00000000  00000000  000003a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000317  00000000  00000000  00000cd3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000581  00000000  00000000  00000fea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000230  00000000  00000000  0000156c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003e0  00000000  00000000  0000179c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006e7  00000000  00000000  00001b7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  00002263  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__ctors_end>:
    7000:	11 e0       	ldi	r17, 0x01	; 1
    7002:	a0 e0       	ldi	r26, 0x00	; 0
    7004:	b1 e0       	ldi	r27, 0x01	; 1
    7006:	ec e0       	ldi	r30, 0x0C	; 12
    7008:	f2 e7       	ldi	r31, 0x72	; 114
    700a:	02 c0       	rjmp	.+4      	; 0x7010 <__ctors_end+0x10>
    700c:	05 90       	lpm	r0, Z+
    700e:	0d 92       	st	X+, r0
    7010:	a2 31       	cpi	r26, 0x12	; 18
    7012:	b1 07       	cpc	r27, r17
    7014:	d9 f7       	brne	.-10     	; 0x700c <__ctors_end+0xc>

00007016 <__do_clear_bss>:
    7016:	21 e0       	ldi	r18, 0x01	; 1
    7018:	a2 e1       	ldi	r26, 0x12	; 18
    701a:	b1 e0       	ldi	r27, 0x01	; 1
    701c:	01 c0       	rjmp	.+2      	; 0x7020 <.do_clear_bss_start>

0000701e <.do_clear_bss_loop>:
    701e:	1d 92       	st	X+, r1

00007020 <.do_clear_bss_start>:
    7020:	a6 31       	cpi	r26, 0x16	; 22
    7022:	b2 07       	cpc	r27, r18
    7024:	e1 f7       	brne	.-8      	; 0x701e <.do_clear_bss_loop>

00007026 <startup_code>:
{
	for (uint8_t i = 0; i < length; i++)
	{
		send_hex_byte(buffer[i]);
	}
}
    7026:	0e 94 1e 38 	call	0x703c	; 0x703c <main_cs>

0000702a <gpio_init>:
    702a:	8f ef       	ldi	r24, 0xFF	; 255
    702c:	87 b9       	out	0x07, r24	; 7
    702e:	8a b1       	in	r24, 0x0a	; 10
    7030:	8f 7e       	andi	r24, 0xEF	; 239
    7032:	8a b9       	out	0x0a, r24	; 10
    7034:	8b b1       	in	r24, 0x0b	; 11
    7036:	80 61       	ori	r24, 0x10	; 16
    7038:	8b b9       	out	0x0b, r24	; 11
    703a:	08 95       	ret

0000703c <main_cs>:
void main_cs(void)
{
    703c:	cf 93       	push	r28
    703e:	df 93       	push	r29
    7040:	cd b7       	in	r28, 0x3d	; 61
    7042:	de b7       	in	r29, 0x3e	; 62
    7044:	62 97       	sbiw	r28, 0x12	; 18
    7046:	0f b6       	in	r0, 0x3f	; 63
    7048:	f8 94       	cli
    704a:	de bf       	out	0x3e, r29	; 62
    704c:	0f be       	out	0x3f, r0	; 63
    704e:	cd bf       	out	0x3d, r28	; 61
	UART_init(9600);
    7050:	80 e8       	ldi	r24, 0x80	; 128
    7052:	95 e2       	ldi	r25, 0x25	; 37
    7054:	0e 94 66 38 	call	0x70cc	; 0x70cc <UART_init>
	timer1_init();
    7058:	0e 94 44 38 	call	0x7088	; 0x7088 <timer1_init>
	gpio_init();
    705c:	0e 94 15 38 	call	0x702a	; 0x702a <gpio_init>
	uint8_t dataReset[] = "BOOTLOADER RESET\n";
    7060:	82 e1       	ldi	r24, 0x12	; 18
    7062:	e0 e0       	ldi	r30, 0x00	; 0
    7064:	f1 e0       	ldi	r31, 0x01	; 1
    7066:	de 01       	movw	r26, r28
    7068:	11 96       	adiw	r26, 0x01	; 1
    706a:	01 90       	ld	r0, Z+
    706c:	0d 92       	st	X+, r0
    706e:	8a 95       	dec	r24
    7070:	e1 f7       	brne	.-8      	; 0x706a <main_cs+0x2e>
	UART_Transmit(dataReset, sizeof(dataReset), 1000);
    7072:	28 ee       	ldi	r18, 0xE8	; 232
    7074:	33 e0       	ldi	r19, 0x03	; 3
    7076:	40 e0       	ldi	r20, 0x00	; 0
    7078:	50 e0       	ldi	r21, 0x00	; 0
    707a:	62 e1       	ldi	r22, 0x12	; 18
    707c:	70 e0       	ldi	r23, 0x00	; 0
    707e:	ce 01       	movw	r24, r28
    7080:	01 96       	adiw	r24, 0x01	; 1
    7082:	0e 94 9e 38 	call	0x713c	; 0x713c <UART_Transmit>
    7086:	ff cf       	rjmp	.-2      	; 0x7086 <main_cs+0x4a>

00007088 <timer1_init>:
static uint32_t volatile countSystick = 0;
// init 1ms timer , clk 16Mhz
void timer1_init()
{
	// Set normal mode
	TCCR1A = 0;
    7088:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = 0;
    708c:	e1 e8       	ldi	r30, 0x81	; 129
    708e:	f0 e0       	ldi	r31, 0x00	; 0
    7090:	10 82       	st	Z, r1
	TCNT1 = 65536 - 2000;
    7092:	80 e3       	ldi	r24, 0x30	; 48
    7094:	98 ef       	ldi	r25, 0xF8	; 248
    7096:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    709a:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	// Set prescaler divide by 8
	TCCR1B |= (1 << CS11);
    709e:	80 81       	ld	r24, Z
    70a0:	82 60       	ori	r24, 0x02	; 2
    70a2:	80 83       	st	Z, r24
	TIMSK1 |= (1 << TOIE1);
    70a4:	ef e6       	ldi	r30, 0x6F	; 111
    70a6:	f0 e0       	ldi	r31, 0x00	; 0
    70a8:	80 81       	ld	r24, Z
    70aa:	81 60       	ori	r24, 0x01	; 1
    70ac:	80 83       	st	Z, r24
	sei();
    70ae:	78 94       	sei
    70b0:	08 95       	ret

000070b2 <getSystick>:
}
uint32_t getSystick()
{
	return countSystick;
    70b2:	60 91 12 01 	lds	r22, 0x0112	; 0x800112 <__data_end>
    70b6:	70 91 13 01 	lds	r23, 0x0113	; 0x800113 <__data_end+0x1>
    70ba:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <__data_end+0x2>
    70be:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <__data_end+0x3>
}
    70c2:	08 95       	ret

000070c4 <is_external_clock>:
uint8_t is_external_clock()
{
	uint8_t fuse_value = 1;
	// uint8_t fuse_value = read_low_fuse();
	return (fuse_value & 0x07) != 0x07;
}
    70c4:	81 e0       	ldi	r24, 0x01	; 1
    70c6:	08 95       	ret

000070c8 <is_CKDIV8>:
uint8_t is_CKDIV8()
{
	uint8_t fuse_value = 1;
	// uint8_t fuse_value = read_low_fuse();
	return (fuse_value & 0x80) != 0; // Check if CKDIV8 bit is set
}
    70c8:	80 e0       	ldi	r24, 0x00	; 0
    70ca:	08 95       	ret

000070cc <UART_init>:

uint8_t UART_init(uint16_t baudrate)
{
    70cc:	cf 93       	push	r28
    70ce:	df 93       	push	r29
    70d0:	ec 01       	movw	r28, r24
	if (is_CKDIV8() && is_external_clock())
    70d2:	0e 94 64 38 	call	0x70c8	; 0x70c8 <is_CKDIV8>
    70d6:	88 23       	and	r24, r24
    70d8:	21 f0       	breq	.+8      	; 0x70e2 <UART_init+0x16>
    70da:	0e 94 62 38 	call	0x70c4	; 0x70c4 <is_external_clock>
    70de:	81 11       	cpse	r24, r1
    70e0:	29 c0       	rjmp	.+82     	; 0x7134 <UART_init+0x68>
	return 1;

	uint16_t ubrr = (uint16_t)(CPU_N / (16UL * baudrate)) - 1; // Calculate UBRR value
    70e2:	ce 01       	movw	r24, r28
    70e4:	a0 e0       	ldi	r26, 0x00	; 0
    70e6:	b0 e0       	ldi	r27, 0x00	; 0
    70e8:	88 0f       	add	r24, r24
    70ea:	99 1f       	adc	r25, r25
    70ec:	aa 1f       	adc	r26, r26
    70ee:	bb 1f       	adc	r27, r27
    70f0:	88 0f       	add	r24, r24
    70f2:	99 1f       	adc	r25, r25
    70f4:	aa 1f       	adc	r26, r26
    70f6:	bb 1f       	adc	r27, r27
    70f8:	9c 01       	movw	r18, r24
    70fa:	ad 01       	movw	r20, r26
    70fc:	22 0f       	add	r18, r18
    70fe:	33 1f       	adc	r19, r19
    7100:	44 1f       	adc	r20, r20
    7102:	55 1f       	adc	r21, r21
    7104:	22 0f       	add	r18, r18
    7106:	33 1f       	adc	r19, r19
    7108:	44 1f       	adc	r20, r20
    710a:	55 1f       	adc	r21, r21
    710c:	60 e0       	ldi	r22, 0x00	; 0
    710e:	74 e2       	ldi	r23, 0x24	; 36
    7110:	84 ef       	ldi	r24, 0xF4	; 244
    7112:	90 e0       	ldi	r25, 0x00	; 0
    7114:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <__udivmodsi4>
    7118:	21 50       	subi	r18, 0x01	; 1
    711a:	31 09       	sbc	r19, r1

	// Set baud rate
	UBRR0H = (uint8_t)(ubrr >> 8);
    711c:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = (uint8_t)(ubrr);
    7120:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>

	// Enable transmitter and receiver
	UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    7124:	88 e1       	ldi	r24, 0x18	; 24
    7126:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>

	// Set frame format: 8 data bits, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    712a:	86 e0       	ldi	r24, 0x06	; 6
    712c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>

	return 0;
    7130:	80 e0       	ldi	r24, 0x00	; 0
    7132:	01 c0       	rjmp	.+2      	; 0x7136 <UART_init+0x6a>
}

uint8_t UART_init(uint16_t baudrate)
{
	if (is_CKDIV8() && is_external_clock())
	return 1;
    7134:	81 e0       	ldi	r24, 0x01	; 1

	// Set frame format: 8 data bits, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);

	return 0;
}
    7136:	df 91       	pop	r29
    7138:	cf 91       	pop	r28
    713a:	08 95       	ret

0000713c <UART_Transmit>:

AVR_status_t UART_Transmit(const uint8_t *data, uint16_t size, uint32_t timeout)
{
    713c:	6f 92       	push	r6
    713e:	7f 92       	push	r7
    7140:	8f 92       	push	r8
    7142:	9f 92       	push	r9
    7144:	af 92       	push	r10
    7146:	bf 92       	push	r11
    7148:	cf 92       	push	r12
    714a:	df 92       	push	r13
    714c:	ef 92       	push	r14
    714e:	ff 92       	push	r15
    7150:	0f 93       	push	r16
    7152:	1f 93       	push	r17
    7154:	cf 93       	push	r28
    7156:	df 93       	push	r29
    7158:	8c 01       	movw	r16, r24
    715a:	3b 01       	movw	r6, r22
    715c:	49 01       	movw	r8, r18
    715e:	5a 01       	movw	r10, r20
	uint32_t startTimer = getSystick()	;
    7160:	0e 94 59 38 	call	0x70b2	; 0x70b2 <getSystick>
    7164:	6b 01       	movw	r12, r22
    7166:	7c 01       	movw	r14, r24
	for (uint16_t i = 0; i < size; i++)
    7168:	c0 e0       	ldi	r28, 0x00	; 0
    716a:	d0 e0       	ldi	r29, 0x00	; 0
    716c:	18 c0       	rjmp	.+48     	; 0x719e <UART_Transmit+0x62>
	{
		// Wait for transmit buffer to be empty
		while (!(UCSR0A & (1 << UDRE0)))
		{
			if ((getSystick() - startTimer) > timeout)
    716e:	0e 94 59 38 	call	0x70b2	; 0x70b2 <getSystick>
    7172:	dc 01       	movw	r26, r24
    7174:	cb 01       	movw	r24, r22
    7176:	8c 19       	sub	r24, r12
    7178:	9d 09       	sbc	r25, r13
    717a:	ae 09       	sbc	r26, r14
    717c:	bf 09       	sbc	r27, r15
    717e:	88 16       	cp	r8, r24
    7180:	99 06       	cpc	r9, r25
    7182:	aa 06       	cpc	r10, r26
    7184:	bb 06       	cpc	r11, r27
    7186:	80 f0       	brcs	.+32     	; 0x71a8 <UART_Transmit+0x6c>
{
	uint32_t startTimer = getSystick()	;
	for (uint16_t i = 0; i < size; i++)
	{
		// Wait for transmit buffer to be empty
		while (!(UCSR0A & (1 << UDRE0)))
    7188:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    718c:	85 ff       	sbrs	r24, 5
    718e:	ef cf       	rjmp	.-34     	; 0x716e <UART_Transmit+0x32>
				return AVR_TIMEOUT;
			}
		}

		// Load data into transmit register
		UDR0 = data[i];
    7190:	f8 01       	movw	r30, r16
    7192:	ec 0f       	add	r30, r28
    7194:	fd 1f       	adc	r31, r29
    7196:	80 81       	ld	r24, Z
    7198:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}

AVR_status_t UART_Transmit(const uint8_t *data, uint16_t size, uint32_t timeout)
{
	uint32_t startTimer = getSystick()	;
	for (uint16_t i = 0; i < size; i++)
    719c:	21 96       	adiw	r28, 0x01	; 1
    719e:	c6 15       	cp	r28, r6
    71a0:	d7 05       	cpc	r29, r7
    71a2:	90 f3       	brcs	.-28     	; 0x7188 <UART_Transmit+0x4c>
		}

		// Load data into transmit register
		UDR0 = data[i];
	}
	return AVR_OK;
    71a4:	80 e0       	ldi	r24, 0x00	; 0
    71a6:	01 c0       	rjmp	.+2      	; 0x71aa <UART_Transmit+0x6e>
		// Wait for transmit buffer to be empty
		while (!(UCSR0A & (1 << UDRE0)))
		{
			if ((getSystick() - startTimer) > timeout)
			{
				return AVR_TIMEOUT;
    71a8:	82 e0       	ldi	r24, 0x02	; 2

		// Load data into transmit register
		UDR0 = data[i];
	}
	return AVR_OK;
}
    71aa:	df 91       	pop	r29
    71ac:	cf 91       	pop	r28
    71ae:	1f 91       	pop	r17
    71b0:	0f 91       	pop	r16
    71b2:	ff 90       	pop	r15
    71b4:	ef 90       	pop	r14
    71b6:	df 90       	pop	r13
    71b8:	cf 90       	pop	r12
    71ba:	bf 90       	pop	r11
    71bc:	af 90       	pop	r10
    71be:	9f 90       	pop	r9
    71c0:	8f 90       	pop	r8
    71c2:	7f 90       	pop	r7
    71c4:	6f 90       	pop	r6
    71c6:	08 95       	ret

000071c8 <__udivmodsi4>:
    71c8:	a1 e2       	ldi	r26, 0x21	; 33
    71ca:	1a 2e       	mov	r1, r26
    71cc:	aa 1b       	sub	r26, r26
    71ce:	bb 1b       	sub	r27, r27
    71d0:	fd 01       	movw	r30, r26
    71d2:	0d c0       	rjmp	.+26     	; 0x71ee <__udivmodsi4_ep>

000071d4 <__udivmodsi4_loop>:
    71d4:	aa 1f       	adc	r26, r26
    71d6:	bb 1f       	adc	r27, r27
    71d8:	ee 1f       	adc	r30, r30
    71da:	ff 1f       	adc	r31, r31
    71dc:	a2 17       	cp	r26, r18
    71de:	b3 07       	cpc	r27, r19
    71e0:	e4 07       	cpc	r30, r20
    71e2:	f5 07       	cpc	r31, r21
    71e4:	20 f0       	brcs	.+8      	; 0x71ee <__udivmodsi4_ep>
    71e6:	a2 1b       	sub	r26, r18
    71e8:	b3 0b       	sbc	r27, r19
    71ea:	e4 0b       	sbc	r30, r20
    71ec:	f5 0b       	sbc	r31, r21

000071ee <__udivmodsi4_ep>:
    71ee:	66 1f       	adc	r22, r22
    71f0:	77 1f       	adc	r23, r23
    71f2:	88 1f       	adc	r24, r24
    71f4:	99 1f       	adc	r25, r25
    71f6:	1a 94       	dec	r1
    71f8:	69 f7       	brne	.-38     	; 0x71d4 <__udivmodsi4_loop>
    71fa:	60 95       	com	r22
    71fc:	70 95       	com	r23
    71fe:	80 95       	com	r24
    7200:	90 95       	com	r25
    7202:	9b 01       	movw	r18, r22
    7204:	ac 01       	movw	r20, r24
    7206:	bd 01       	movw	r22, r26
    7208:	cf 01       	movw	r24, r30
    720a:	08 95       	ret
